<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Video + GPS CSV Sync</title>

  <!-- Leaflet (map) -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    :root{
      --bg:#0b0f14; --panel:#111823; --panel2:#0e151f;
      --text:#e6edf3; --muted:#9fb0c0;
      --border:rgba(255,255,255,.10); --shadow:rgba(0,0,0,.35);
      --radius:14px; --gap:12px;
      --scrub:#ff3b30;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}

    .wrap{
      min-height:100dvh;
      padding:12px;
      display:grid;
      grid-template-rows:auto auto 1fr auto;
      gap:var(--gap);
    }

    /* Header: files only */
    .header{
      display:flex;flex-wrap:wrap;gap:10px;align-items:flex-end;justify-content:space-between;
      background:linear-gradient(180deg,var(--panel),var(--panel2));
      border:1px solid var(--border);border-radius:var(--radius);
      padding:10px;box-shadow:0 10px 30px var(--shadow)
    }
    .headerLeft{display:flex;flex-wrap:wrap;gap:10px;align-items:flex-end}
    .block{display:flex;flex-direction:column;gap:4px;min-width:160px}
    label{font-size:12px;color:var(--muted)}
    input[type="file"], input[type="number"], button{
      background:rgba(255,255,255,.05);
      border:1px solid var(--border);
      color:var(--text);
      border-radius:10px;
      padding:8px 10px;
      font-size:14px
    }
    button{cursor:pointer;user-select:none;white-space:nowrap}
    button:active{transform:scale(.99)}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}

    .notice{
      background:rgba(255,59,48,0.12);
      border:1px solid rgba(255,59,48,0.35);
      padding:8px 10px;border-radius:12px;
      font-size:12px;color:rgba(255,255,255,0.85);
      display:none;
    }

    /* Content layout (default = LARGE) */
    .content{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:var(--gap);
      align-items:stretch;
    }

    .card{
      background:linear-gradient(180deg,var(--panel),var(--panel2));
      border:1px solid var(--border);
      border-radius:var(--radius);
      overflow:hidden;
      box-shadow:0 10px 30px var(--shadow);
      position:relative;
      display:flex;
      flex-direction:column;
    }
    .cardTitle{
      position:absolute;top:10px;left:10px;z-index:10;
      font-size:12px;color:var(--muted);
      background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.10);
      padding:6px 10px;border-radius:999px;
      backdrop-filter:blur(6px)
    }

    /* Always-landscape tiles */
    .tile{
      width:100%;
      aspect-ratio: 16 / 9;
      background:#000;
      position:relative;
      overflow:hidden;
      flex: 1 1 auto;
    }
    video{
      width:100%;
      height:100%;
      object-fit:contain; /* portrait stays intact inside landscape */
      background:#000;
    }
    #map{width:100%;height:100%}

    /* Chart */
    .chartCard{
      background:linear-gradient(180deg,var(--panel),var(--panel2));
      border:1px solid var(--border);
      border-radius:var(--radius);
      overflow:hidden;
      box-shadow:0 10px 30px var(--shadow);
      padding:10px;
    }
    .topBar{
      display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap;
      margin-bottom:8px;
    }
    .pill{
      font-size:12px;color:var(--muted);
      background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.10);
      padding:6px 10px;border-radius:999px;
    }
    .controlsRow{
      display:grid;
      grid-template-columns:1fr auto 1fr;
      align-items:center;
      gap:10px;
      margin:6px 0 8px 0;
    }
    .controlsRow .left, .controlsRow .right{
      display:flex;gap:8px;flex-wrap:wrap;align-items:center;
    }
    .controlsRow .center{
      display:flex;gap:8px;flex-wrap:nowrap;align-items:center;justify-content:center;
      min-width:0;
    }
    .status{
      font-size:12px;color:var(--muted);
      display:flex;gap:10px;flex-wrap:wrap;align-items:center;
      margin-bottom:8px;
    }
    .status b{color:var(--text);font-weight:600}

    #chartWrap{position:relative;height:220px;touch-action:none}
    #chart{width:100%;height:220px}

    #videoTimelineWrap{margin-top:10px;touch-action:none}
    #videoTimeline{
      width:100%;
      height:110px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.25);
      touch-action:none;
    }

    /* Settings below scrub */
    .settingsPanel{
      margin-top:10px;
      border:1px solid rgba(255,255,255,.10);
      border-radius:12px;
      background:rgba(0,0,0,.22);
      padding:10px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .settingsPanel .block{min-width:0}
    .settingsPanel .row{gap:8px}
    .settingsPanel .hint{font-size:12px;color:var(--muted)}
    .settingsPanel .mini{
      font-size:12px;color:rgba(255,255,255,0.75);
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.10);
      padding:6px 10px;border-radius:10px;
    }

    .small{font-size:12px;color:var(--muted);line-height:1.3;margin-top:8px}

    /* SMALL MODE: stack content */
    body.mode-small .content{grid-template-columns:1fr}
    body.mode-small .controlsRow{grid-template-columns:1fr;gap:8px}
    body.mode-small .controlsRow .left,
    body.mode-small .controlsRow .center,
    body.mode-small .controlsRow .right{justify-content:center}
    body.mode-small .settingsPanel{grid-template-columns:1fr}

    /* Auto small on narrow screens, unless user forces large */
    @media (max-width: 860px){
      body:not(.mode-large-forced) .content{grid-template-columns:1fr}
    }
    @media (max-width: 420px){
      body:not(.mode-large-forced) .controlsRow{grid-template-columns:1fr;gap:8px}
      body:not(.mode-large-forced) .controlsRow .left,
      body:not(.mode-large-forced) .controlsRow .center,
      body:not(.mode-large-forced) .controlsRow .right{justify-content:center}
      body:not(.mode-large-forced) .settingsPanel{grid-template-columns:1fr}
      .block{min-width:140px}
    }
  </style>
</head>

<body class="mode-large">
  <div class="wrap">
    <!-- Header: file inputs only -->
    <div class="header">
      <div class="headerLeft">
        <div class="block">
          <label>Video (local)</label>
          <input id="videoFile" type="file" accept="video/*" />
        </div>

        <div class="block">
          <label>CSV (Vakaros or RED)</label>
          <input id="csvFile" type="file" accept=".csv,text/csv" />
        </div>

        <div class="block" style="min-width:220px;">
          <label>Quick</label>
          <div class="row">
            <button id="btnFit" title="Fit map to track">Fit track</button>
          </div>
        </div>
      </div>

      <!-- no settings here anymore -->
      <div style="display:flex;gap:10px;align-items:flex-end;">
        <div class="block" style="min-width:170px;">
          <label>Layout</label>
          <button id="btnToggleMode" title="Toggle between large (side-by-side) and small (stacked) layouts">Small mode</button>
        </div>
      </div>
    </div>

    <div id="notice" class="notice"></div>

    <div class="content">
      <div class="card">
        <div class="cardTitle">Video</div>
        <div class="tile">
          <video id="video" controls playsinline></video>
        </div>
      </div>

      <div class="card">
        <div class="cardTitle">GPS track</div>
        <div class="tile">
          <div id="map"></div>
        </div>
      </div>
    </div>

    <div class="chartCard">
      <div class="topBar">
        <div class="pill">SOG — drag to pan; red center scrub; marker follows</div>
        <div class="pill">Map window: visible scrub range highlighted</div>
      </div>

      <div class="controlsRow">
        <div class="left">
          <button id="zoomIn" title="Zoom in">+</button>
          <button id="zoomOut" title="Zoom out">−</button>
          <button id="centerZero" title="Put center exactly at t=0">Center t=0</button>
        </div>

        <div class="center">
          <button id="back10" title="Back 10 seconds">−10s</button>
          <button id="playPause" title="Play / Pause">Play</button>
          <button id="fwd10" title="Forward 10 seconds">+10s</button>
        </div>

        <div class="right"></div>
      </div>

      <div class="status">
        <span>center t: <b id="tRead">—</b></span>
        <span>SOG: <b id="sogRead">—</b> kt</span>
        <span>COG: <b id="cogRead">—</b>°</span>
        <span>HDG: <b id="hdgRead">—</b>°</span>
        <span>Heel: <b id="heelRead">—</b>°</span>
        <span>Trim: <b id="trimRead">—</b>°</span>
        <span>Torso: <b id="torsoRead">—</b>°</span>
        <span>video t: <b id="vRead">—</b></span>
        <span>video@center: <b id="inVidRead">—</b></span>
      </div>

      <div id="chartWrap">
        <canvas id="chart"></canvas>
      </div>

      <div id="videoTimelineWrap">
        <canvas id="videoTimeline"></canvas>
      </div>

      <!-- Settings moved BELOW scrub line -->
      <div class="settingsPanel">
        <div class="block">
          <label>Sync offset (H:M:S)</label>
          <div class="row">
            <input id="offsetHours" type="number" step="1" value="0" style="width:70px;" placeholder="H" title="Hours" />
            <span style="color:var(--muted);">:</span>
            <input id="offsetMin" type="number" step="1" value="0" style="width:70px;" placeholder="M" title="Minutes" />
            <span style="color:var(--muted);">:</span>
            <input id="offsetSec" type="number" step="0.1" value="0" style="width:70px;" placeholder="S" title="Seconds" />
            <button id="btnSetOffset" title="Offset = centerTime - currentVideoTime">Set from center</button>
            <button id="btnAutoAlign" title="Auto-align using CSV start time and video start time (best effort)">Auto-align</button>
          </div>
          <div class="hint">GPS elapsed = videoTime + offset. Offset is defined from the <b>start</b> of the video.</div>
        </div>

        <div class="block">
          <label>Timezone shift (hours)</label>
          <div class="row">
            <button id="tzMinus">−1h</button>
            <input id="tzShiftHours" type="number" step="1" value="0" style="width:90px;" />
            <button id="tzPlus">+1h</button>
            <button id="tzApply" title="Apply hour shift to auto alignment (common when timestamps differ by timezone)">Apply</button>
          </div>
          <div class="hint">If auto-align is off by whole hours, set this and Apply.</div>
        </div>

        <div class="block">
          <label>Version</label>
          <div class="mini">v0.9 — video offset from start + TZ shift + map window highlight</div>
        </div>

        <div class="block">
          <label>Layout</label>
          <div class="mini">Use the top-right button to switch Large/Small mode.</div>
        </div>
      </div>

      <div class="small">
        The chart includes a padded “null” segment before t=0 so you can scrub the red center line to the very first data point.
      </div>
    </div>
  </div>

  <script>
    // =========================
    // Helpers
    // =========================
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function toNum(x){ const v = parseFloat(x); return Number.isFinite(v) ? v : NaN; }
    function splitCSVLine(line){ return line.split(",").map(s => s.trim()); }

    function parseISOish(ts) {
      if (!ts) return null;
      const fixed = ts.replace(/([+-]\d{2})(\d{2})$/, "$1:$2");
      const d = new Date(fixed);
      return isNaN(d.getTime()) ? null : d;
    }

    function fmtClock(sec){
      if (!Number.isFinite(sec)) return "—";
      sec = Math.max(0, sec);
      const h = Math.floor(sec/3600);
      const m = Math.floor((sec%3600)/60);
      const s = Math.floor(sec%60);
      const ms = Math.floor((sec - Math.floor(sec))*1000);
      if (h>0) return `${h}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${String(ms).padStart(3,'0')}`;
      return `${m}:${String(s).padStart(2,'0')}.${String(ms).padStart(3,'0')}`;
    }

    function showNotice(msg){
      const el = document.getElementById("notice");
      if (!msg){ el.style.display="none"; el.textContent=""; return; }
      el.textContent = msg;
      el.style.display = "block";
    }

    // =========================
    // State
    // =========================
    const state = {
      points: [],
      t0Abs: null,
      duration: 0,

      padStartSec: 3.0,
      padNullSteps: 20,

      centerTe: 0,
      spanSec: 60,

      chart: null,

      // map layers
      polyAll: null,
      polyWindow: null,
      marker: null,

      // current visible window [wMin, wMax]
      wMin: 0,
      wMax: 0,

      dragging: false,
      dragStartX: 0,
      dragStartCenter: 0,

      vLoaded: false,
      vDuration: NaN,

      // Video "start time" (best-effort from file lastModified)
      videoStartAbsMs: null,

      playing: false,
      playLastTs: 0,

      lastIdx: 0,
      raf: null
    };

    // =========================
    // DOM
    // =========================
    const bodyEl = document.body;
    const btnToggleMode = document.getElementById("btnToggleMode");

    const videoEl = document.getElementById("video");
    const videoFileEl = document.getElementById("videoFile");
    const csvFileEl = document.getElementById("csvFile");

    const offsetHoursEl = document.getElementById("offsetHours");
    const offsetMinEl = document.getElementById("offsetMin");
    const offsetEl = document.getElementById("offsetSec");
    const btnAutoAlign = document.getElementById("btnAutoAlign");
    const btnSetOffset = document.getElementById("btnSetOffset");

    const tzShiftEl = document.getElementById("tzShiftHours");
    const tzMinusBtn = document.getElementById("tzMinus");
    const tzPlusBtn = document.getElementById("tzPlus");
    const tzApplyBtn = document.getElementById("tzApply");

    const btnFit = document.getElementById("btnFit");

    const zoomInBtn = document.getElementById("zoomIn");
    const zoomOutBtn = document.getElementById("zoomOut");
    const centerZeroBtn = document.getElementById("centerZero");

    const back10Btn = document.getElementById("back10");
    const playPauseBtn = document.getElementById("playPause");
    const fwd10Btn = document.getElementById("fwd10");

    const tRead = document.getElementById("tRead");
    const sogRead = document.getElementById("sogRead");
    const cogRead = document.getElementById("cogRead");
    const hdgRead = document.getElementById("hdgRead");
    const heelRead = document.getElementById("heelRead");
    const trimRead = document.getElementById("trimRead");
    const torsoRead = document.getElementById("torsoRead");
    const vRead = document.getElementById("vRead");
    const inVidRead = document.getElementById("inVidRead");

    const chartCanvas = document.getElementById("chart");
    const videoTimeline = document.getElementById("videoTimeline");
    const vtCtx = videoTimeline.getContext("2d");

    // =========================
    // Layout toggle
    // =========================
    function setModeSmall(on){
      if (on){
        bodyEl.classList.add("mode-small");
        bodyEl.classList.remove("mode-large-forced");
        btnToggleMode.textContent = "Large mode";
      } else {
        bodyEl.classList.remove("mode-small");
        bodyEl.classList.add("mode-large-forced");
        btnToggleMode.textContent = "Small mode";
      }
      setTimeout(()=>{ try{ map.invalidateSize(); }catch(e){} }, 60);
      setTimeout(()=>{ applyWindow(true); drawVideoTimeline(); }, 80);
    }
    btnToggleMode.addEventListener("click", () => {
      const isSmall = bodyEl.classList.contains("mode-small");
      setModeSmall(!isSmall);
    });
    btnToggleMode.textContent = "Small mode";

    // =========================
    // Map
    // =========================
    const map = L.map("map", { zoomControl: true });
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: "&copy; OpenStreetMap contributors"
    }).addTo(map);
    map.setView([0,0], 2);

    function fitTrack(){
      const layer = state.polyAll;
      if (!layer) return;
      const b = layer.getBounds();
      if (b.isValid()) map.fitBounds(b.pad(0.1));
    }

    // =========================
    // Chart
    // =========================
    const centerLinePlugin = {
      id: "centerLine",
      afterDatasetsDraw(chart){
        const yScale = chart.scales.y;
        if (!yScale) return;
        const x = (chart.chartArea.left + chart.chartArea.right) / 2;
        const ctx = chart.ctx;
        ctx.save();
        ctx.beginPath();
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#ff3b30";
        ctx.moveTo(x, yScale.top);
        ctx.lineTo(x, yScale.bottom);
        ctx.stroke();
        ctx.restore();
      }
    };

    function buildChartDataset(){
      const arr = [];
      const steps = Math.max(6, state.padNullSteps);
      const pad = state.padStartSec;

      for (let i=steps; i>=1; i--){
        const x = -pad * (i/steps);
        arr.push({ x, y: null });
      }
      arr.push({ x: 0, y: null });

      for (const p of state.points){
        arr.push({ x: p.te, y: p.sogKt });
      }
      return arr;
    }

    function makeChart(){
      const ctx = chartCanvas.getContext("2d");
      const data = buildChartDataset();

      if (state.chart) state.chart.destroy();

      state.chart = new Chart(ctx, {
        type: "line",
        data: { datasets: [{ data, borderWidth: 2, pointRadius: 0, tension: 0.15, spanGaps: false }] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: false,
          events: [],
          plugins: { legend: { display: false } },
          scales: {
            x: {
              type: "linear",
              title: { display: true, text: "Time (s from recording start)" },
              grid: { color: "rgba(255,255,255,0.08)" },
              ticks: { color: "rgba(255,255,255,0.75)" }
            },
            y: {
              title: { display: true, text: "Knots" },
              grid: { color: "rgba(255,255,255,0.08)" },
              ticks: { color: "rgba(255,255,255,0.75)" }
            }
          }
        },
        plugins: [centerLinePlugin]
      });

      applyWindow(true);
    }

    function applyWindow(redrawTimeline){
      if (!state.chart) return;

      const minTe = -state.padStartSec;
      const maxTe = state.duration;

      state.centerTe = clamp(state.centerTe, minTe, maxTe);

      const spanMax = Math.max(2, (maxTe - minTe) || 2);
      const span = clamp(state.spanSec, 2, spanMax);
      const half = span/2;

      // keep center anchored; window shrinks at edges
      let wMin = clamp(state.centerTe - half, minTe, maxTe);
      let wMax = clamp(state.centerTe + half, minTe, maxTe);
      if (wMax - wMin < 0.1) {
        wMin = clamp(state.centerTe - 0.5, minTe, maxTe);
        wMax = clamp(state.centerTe + 0.5, minTe, maxTe);
      }

      state.wMin = wMin;
      state.wMax = wMax;

      state.chart.options.scales.x.min = wMin;
      state.chart.options.scales.x.max = wMax;
      state.chart.update("none");

      updateMapWindowHighlight();

      if (redrawTimeline) drawVideoTimeline();
    }

    // =========================
    // CSV parsing
    // =========================
    function detectFormat(headerLower){
      if (headerLower.includes("sog_kts") && headerLower.includes("timestamp")) return "vakaros";
      if (headerLower.includes("unit_id") && headerLower.includes("timestamp_ms") && headerLower.includes("sog_mps")) return "red";
      return "unknown";
    }

    async function loadCSV(file){
      const text = await file.text();
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      if (lines.length < 2) throw new Error("CSV seems empty.");

      const header = splitCSVLine(lines[0]).map(s => s.toLowerCase());
      const idx = (name) => header.indexOf(name.toLowerCase());
      const fmt = detectFormat(header);
      if (fmt === "unknown") throw new Error("Unknown CSV format.");

      const pts = [];

      if (fmt === "vakaros"){
        const iTs = idx("timestamp");
        const iLat = idx("latitude");
        const iLon = idx("longitude");
        const iSog = idx("sog_kts");
        const iCog = idx("cog");
        const iHdg = idx("hdg_true");
        const iHeel = idx("heel");
        const iTrim = idx("trim");
        if (iTs<0 || iLat<0 || iLon<0 || iSog<0) throw new Error("Vakaros CSV missing required columns.");

        for (let k=1;k<lines.length;k++){
          const row = splitCSVLine(lines[k]);
          if (row.length < header.length) continue;

          const d = parseISOish(row[iTs]);
          if (!d) continue;

          const lat = toNum(row[iLat]);
          const lon = toNum(row[iLon]);
          const sogKt = toNum(row[iSog]);
          if (!Number.isFinite(sogKt)) continue;

          pts.push({
            tAbs: d, te: 0,
            lat: Number.isFinite(lat) ? lat : NaN,
            lon: Number.isFinite(lon) ? lon : NaN,
            sogKt,
            cog: (iCog>=0)? toNum(row[iCog]) : NaN,
            hdg: (iHdg>=0)? toNum(row[iHdg]) : NaN,
            heel: (iHeel>=0)? toNum(row[iHeel]) : NaN,
            trim: (iTrim>=0)? toNum(row[iTrim]) : NaN,
            torso: NaN
          });
        }
        if (pts.length < 2) throw new Error("Not enough valid rows parsed.");

        pts.sort((a,b)=>a.tAbs - b.tAbs);
        const t0 = pts[0].tAbs.getTime();
        for (const p of pts) p.te = (p.tAbs.getTime() - t0)/1000;
        state.t0Abs = pts[0].tAbs;
      }

      if (fmt === "red"){
        const iMs = idx("timestamp_ms");
        const iIso = idx("iso_time");
        const iLat = idx("lat");
        const iLon = idx("lon");
        const iSog = idx("sog_mps");
        const iCog = idx("heading_deg");
        const iHdg = idx("mag_hdg");
        const iRoll = idx("roll_deg");
        const iPitch = idx("pitch_deg");
        const iTorso = idx("torso_angle");

        if (iMs<0 || iSog<0) throw new Error("RED CSV missing required columns (timestamp_ms, sog_mps).");

        let firstAbs = null;
        let firstMs = null;
        for (let k=1;k<lines.length;k++){
          const row = splitCSVLine(lines[k]);
          const ms = parseInt(row[iMs], 10);
          const d = (iIso>=0) ? parseISOish(row[iIso]) : null;
          if (d && Number.isFinite(ms)) { firstAbs = d; firstMs = ms; break; }
        }

        for (let k=1;k<lines.length;k++){
          const row = splitCSVLine(lines[k]);
          if (row.length < 5) continue;

          const ms = parseInt(row[iMs], 10);
          if (!Number.isFinite(ms)) continue;

          const tAbsRow = (iIso>=0) ? parseISOish(row[iIso]) : null;
          let tAbs = tAbsRow;
          if (!tAbs && firstAbs && firstMs != null) tAbs = new Date(firstAbs.getTime() + (ms - firstMs));

          const lat = (iLat>=0) ? toNum(row[iLat]) : NaN;
          const lon = (iLon>=0) ? toNum(row[iLon]) : NaN;

          const sogMps = toNum(row[iSog]);
          if (!Number.isFinite(sogMps)) continue;
          const sogKt = sogMps * 1.943844;

          const cog = (iCog>=0) ? toNum(row[iCog]) : NaN;
          const hdg = (iHdg>=0) ? toNum(row[iHdg]) : NaN;

          pts.push({
            tAbs, te: 0,
            lat: Number.isFinite(lat) ? lat : NaN,
            lon: Number.isFinite(lon) ? lon : NaN,
            sogKt,
            cog: Number.isFinite(cog) ? cog : (Number.isFinite(hdg) ? hdg : NaN),
            hdg: Number.isFinite(hdg) ? hdg : NaN,
            heel: (iRoll>=0)? toNum(row[iRoll]) : NaN,
            trim: (iPitch>=0)? toNum(row[iPitch]) : NaN,
            torso: (iTorso>=0)? toNum(row[iTorso]) : NaN
          });
        }
        if (pts.length < 2) throw new Error("Not enough valid rows parsed.");

        if (pts.some(p => p.tAbs instanceof Date && !isNaN(p.tAbs.getTime()))) {
          pts.sort((a,b)=>a.tAbs - b.tAbs);
          const t0 = pts.find(p => p.tAbs)?.tAbs?.getTime();
          for (const p of pts) p.te = (p.tAbs.getTime() - t0)/1000;
          state.t0Abs = pts.find(p => p.tAbs)?.tAbs ?? null;
        } else {
          for (let i=0;i<pts.length;i++) pts[i].te = i;
          state.t0Abs = null;
        }
      }

      state.points = pts.filter(p => Number.isFinite(p.te));
      state.duration = state.points[state.points.length - 1].te;

      state.centerTe = -Math.min(state.padStartSec, 2.0);
      state.spanSec = Math.min(60, Math.max(6, state.duration + state.padStartSec));

      rebuildMap();
      makeChart();
      updateAtCenter(true);

      // after CSV import, if we have video start time, attempt auto align once
      maybeAutoAlign("csv");

      setTimeout(()=>{ try{ map.invalidateSize(); }catch(e){} }, 60);
    }

    // =========================
    // Map rebuild + highlight window
    // =========================
    function rebuildMap(){
      const latlngsAll = state.points
        .filter(p => Number.isFinite(p.lat) && Number.isFinite(p.lon))
        .map(p => [p.lat, p.lon]);

      if (state.polyAll) state.polyAll.remove();
      if (state.polyWindow) state.polyWindow.remove();
      if (state.marker) state.marker.remove();

      if (latlngsAll.length >= 2) {
        // full track (lighter blue)
        state.polyAll = L.polyline(latlngsAll, { weight: 4, opacity: 0.55, color: "#4ea1ff" }).addTo(map);

        // visible window track (darker blue)
        state.polyWindow = L.polyline([], { weight: 7, opacity: 0.85, color: "#1f6fff" }).addTo(map);

        // red scrub marker
        state.marker = L.circleMarker(latlngsAll[0], {
          radius: 9, weight: 3, color: "#ff3b30", fillColor: "#ff3b30", fillOpacity: 0.92
        }).addTo(map);
        state.marker.bringToFront();

        const b = state.polyAll.getBounds();
        if (b.isValid()) map.fitBounds(b.pad(0.1));

        updateMapWindowHighlight();
      } else {
        state.polyAll = null;
        state.polyWindow = null;
        state.marker = null;
        map.setView([0,0], 2);
      }
    }

    function updateMapWindowHighlight(){
      if (!state.polyWindow) return;
      if (!state.points.length) return;

      const wMin = state.wMin ?? 0;
      const wMax = state.wMax ?? 0;

      const latlngsWindow = [];
      for (const p of state.points){
        if (p.te < wMin || p.te > wMax) continue;
        if (!Number.isFinite(p.lat) || !Number.isFinite(p.lon)) continue;
        latlngsWindow.push([p.lat, p.lon]);
      }

      state.polyWindow.setLatLngs(latlngsWindow);
      // keep red marker on top
      if (state.marker) state.marker.bringToFront();
    }

    function fitTrackBtn(){
      fitTrack();
    }

    // =========================
    // Video timing + alignment (OFFSET FROM START)
    // =========================
    function getOffsetSec(){
      const h = parseInt(offsetHoursEl.value, 10) || 0;
      const m = parseInt(offsetMinEl.value, 10) || 0;
      const s = parseFloat(offsetEl.value) || 0;
      return h * 3600 + m * 60 + s;
    }
    function setOffsetSec(v){
      if (!Number.isFinite(v)) v = 0;
      const negative = v < 0;
      v = Math.abs(v);
      const h = Math.floor(v / 3600);
      const m = Math.floor((v % 3600) / 60);
      const s = v % 60;
      offsetHoursEl.value = (negative ? -h : h);
      offsetMinEl.value = m;
      offsetEl.value = s.toFixed(2);
    }
    function getTzShiftHours(){
      const v = parseInt(tzShiftEl.value, 10);
      return Number.isFinite(v) ? v : 0;
    }

    // We treat file.lastModified as the START time of the video (best-effort).
    // If it’s actually end time on your platform, the TZ shift controls will still help for whole-hour issues,
    // and you can also Set-from-center for fine alignment.
    function computeAutoOffsetSec(){
      if (!state.videoStartAbsMs) return null;
      if (!(state.t0Abs instanceof Date) || isNaN(state.t0Abs.getTime())) return null;

      const tzShift = getTzShiftHours() * 3600;
      const videoStartAbs = new Date(state.videoStartAbsMs + tzShift*1000);
      const off = (videoStartAbs.getTime() - state.t0Abs.getTime()) / 1000;
      return off;
    }

    function maybeAutoAlign(reason){
      // only auto-align if both sides present
      if (!state.vLoaded || !state.points.length) return;

      const off = computeAutoOffsetSec();
      if (off == null){
        if (state.points.length && !(state.t0Abs instanceof Date)) {
          showNotice("Auto-align needs absolute timestamps in the CSV (Vakaros timestamp or RED iso_time).");
        }
        return;
      }

      setOffsetSec(off);
      updateVideoPlacementNotice();
      drawVideoTimeline();
      updateAtCenter(true);

      // show a hint if it looks badly out of range (common: timezone)
      const seg = videoSeg();
      if (seg){
        const minTe = -state.padStartSec;
        const maxTe = state.duration;
        const totallyOutside = (seg.b < minTe || seg.a > maxTe);
        if (totallyOutside){
          showNotice("Auto-align placed the video outside the CSV range. Try Timezone shift (± hours) then Apply, or use Set-from-center.");
        } else {
          // only clear if the prior notice was about alignment; keep range notices
          // (we'll let updateVideoPlacementNotice handle final message)
        }
      }
    }

    function videoSeg(){
      if (!state.vLoaded) return null;
      const a = getOffsetSec();
      const b = a + state.vDuration;
      return {a,b};
    }
    function centerIsInVideo(){
      const seg = videoSeg();
      if (!seg) return false;
      return state.centerTe >= seg.a && state.centerTe <= seg.b;
    }

    function updateVideoPlacementNotice(){
      if (!state.vLoaded || !state.points.length){
        // don't overwrite other notices (but simplest: clear)
        // caller will set if needed
        return;
      }
      const seg = videoSeg();
      const minTe = -state.padStartSec;
      const maxTe = state.duration;

      if (seg.b < minTe || seg.a > maxTe){
        showNotice("Video timing is completely outside the CSV time range (adjust offset / timezone shift / Set-from-center).");
        return;
      }
      if (seg.a < minTe || seg.b > maxTe){
        showNotice("Video overlaps CSV, but part of the video lies outside the CSV time range.");
        return;
      }
      // only clear if no other message is relevant
      showNotice("");
    }

    function followCenterToVideo(forceSeek){
      if (!state.vLoaded) {
        vRead.textContent = "—";
        inVidRead.textContent = "no video";
        return;
      }
      const inside = centerIsInVideo();
      inVidRead.textContent = inside ? "IN VIDEO" : "outside video";

      if (inside && forceSeek) {
        const vt = state.centerTe - getOffsetSec();
        videoEl.currentTime = clamp(vt, 0, videoEl.duration);
      }
      vRead.textContent = fmtClock(videoEl.currentTime);
    }

    // =========================
    // Data lookup / readouts
    // =========================
    function findIndexForTime(te){
      const pts = state.points;
      if (!pts.length) return 0;
      const t = clamp(te, 0, state.duration);

      if (t <= pts[0].te) return 0;
      if (t >= pts[pts.length-1].te) return pts.length-1;

      let i = clamp(state.lastIdx, 0, pts.length-2);
      while (i < pts.length-2 && pts[i+1].te < t) i++;
      while (i > 0 && pts[i].te > t) i--;

      if (!(pts[i].te <= t && t <= pts[i+1].te)) {
        let lo=0, hi=pts.length-1;
        while (lo+1<hi){
          const mid=(lo+hi)>>1;
          if (pts[mid].te <= t) lo=mid; else hi=mid;
        }
        i=lo;
      }
      state.lastIdx=i;

      const a=pts[i], b=pts[i+1];
      return (Math.abs(a.te - t) <= Math.abs(b.te - t)) ? i : (i+1);
    }

    function setReadouts(p){
      if (!p) return;
      if (p.tAbs instanceof Date && !isNaN(p.tAbs.getTime())) tRead.textContent = p.tAbs.toISOString().replace(".000Z","Z");
      else tRead.textContent = `${p.te.toFixed(2)}s`;

      sogRead.textContent = Number.isFinite(p.sogKt) ? p.sogKt.toFixed(2) : "—";
      cogRead.textContent = Number.isFinite(p.cog) ? p.cog.toFixed(1) : "—";
      hdgRead.textContent = Number.isFinite(p.hdg) ? p.hdg.toFixed(1) : "—";
      heelRead.textContent = Number.isFinite(p.heel) ? p.heel.toFixed(2) : "—";
      trimRead.textContent = Number.isFinite(p.trim) ? p.trim.toFixed(2) : "—";
      torsoRead.textContent = Number.isFinite(p.torso) ? p.torso.toFixed(2) : "—";
    }

    function updateAtCenter(seekVideo){
      if (!state.points.length) return;

      const idx = findIndexForTime(state.centerTe);
      const p = state.points[idx];
      setReadouts(p);

      // marker update (nearest valid lat/lon)
      if (state.marker) {
        let j = idx;
        if (!(Number.isFinite(p.lat) && Number.isFinite(p.lon))) {
          let found = -1;
          for (let r=1;r<60;r++){
            const a = idx-r, b = idx+r;
            if (a>=0 && Number.isFinite(state.points[a].lat) && Number.isFinite(state.points[a].lon)) { found=a; break; }
            if (b<state.points.length && Number.isFinite(state.points[b].lat) && Number.isFinite(state.points[b].lon)) { found=b; break; }
          }
          if (found >= 0) j = found;
        }
        const q = state.points[j];
        if (Number.isFinite(q.lat) && Number.isFinite(q.lon)) {
          state.marker.setLatLng([q.lat, q.lon]);
          state.marker.bringToFront();
        }
      }

      followCenterToVideo(seekVideo);
      drawVideoTimeline();
      if (state.vLoaded && state.points.length) updateVideoPlacementNotice();
    }

    // =========================
    // Video timeline canvas
    // =========================
    function resizeTimelineCanvas(){
      const dpr = window.devicePixelRatio || 1;
      const rect = videoTimeline.getBoundingClientRect();
      const w = Math.max(10, Math.floor(rect.width));
      const h = Math.max(10, Math.floor(rect.height));
      videoTimeline.width = Math.floor(w * dpr);
      videoTimeline.height = Math.floor(h * dpr);
      vtCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
      return { w, h };
    }

    function roundRect(ctx, x, y, w, h, r, fill, stroke) {
      const radius = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.arcTo(x + w, y, x + w, y + h, radius);
      ctx.arcTo(x + w, y + h, x, y + h, radius);
      ctx.arcTo(x, y + h, x, y, radius);
      ctx.arcTo(x, y, x + w, y, radius);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    function drawVideoTimeline(){
      const { w, h } = resizeTimelineCanvas();
      const ctx = vtCtx;
      ctx.clearRect(0,0,w,h);

      if (!state.points.length) {
        ctx.fillStyle = "rgba(255,255,255,0.65)";
        ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillText("Load CSV to enable timeline.", 10, 22);
        return;
      }

      const minTe = -state.padStartSec;
      const maxTe = state.duration;

      const span = state.spanSec;
      const half = span/2;

      const wMin = clamp(state.centerTe - half, minTe, maxTe);
      const wMax = clamp(state.centerTe + half, minTe, maxTe);

      const pad = 10;
      const barY = 44;
      const barH = 18;
      const barX = pad;
      const barW = w - 2*pad;

      const xForTe = (te) => {
        if (wMax <= wMin) return barX;
        const u = (te - wMin) / (wMax - wMin);
        return barX + u * barW;
      };

      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      ctx.fillStyle = "rgba(255,255,255,0.05)";
      roundRect(ctx, barX, barY, barW, barH, 10, true, true);

      // negative pad shading
      if (wMin < 0) {
        const ax = xForTe(wMin);
        const bx = xForTe(Math.min(0, wMax));
        ctx.fillStyle = "rgba(255,255,255,0.03)";
        roundRect(ctx, ax, barY, Math.max(0, bx-ax), barH, 10, true, false);
      }

      // video segment
      if (state.vLoaded) {
        const seg = videoSeg();
        const clipA = clamp(seg.a, wMin, wMax);
        const clipB = clamp(seg.b, wMin, wMax);
        if (clipB > clipA) {
          const ax = xForTe(clipA);
          const bx = xForTe(clipB);
          ctx.fillStyle = "rgba(103, 232, 249, 0.18)";
          ctx.strokeStyle = "rgba(103, 232, 249, 0.55)";
          roundRect(ctx, ax, barY, (bx-ax), barH, 10, true, true);
        }
        const playTe = (videoEl.currentTime || 0) + getOffsetSec();
        if (playTe >= wMin && playTe <= wMax) {
          const px = xForTe(playTe);
          ctx.fillStyle = "rgba(103, 232, 249, 0.95)";
          ctx.beginPath(); ctx.arc(px, barY + barH/2, 4.5, 0, Math.PI*2); ctx.fill();
        }
      }

      // red center scrub line
      const cx = barX + barW/2;
      ctx.strokeStyle = "#ff3b30";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(cx, barY - 10);
      ctx.lineTo(cx, barY + barH + 14);
      ctx.stroke();

      // labels
      ctx.fillStyle = "rgba(255,255,255,0.65)";
      ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textBaseline = "middle";
      ctx.fillText(`${wMin.toFixed(1)}s`, barX, 22);
      const rightLabel = `${wMax.toFixed(1)}s`;
      const rW = ctx.measureText(rightLabel).width;
      ctx.fillText(rightLabel, barX + barW - rW, 22);

      ctx.restore();
    }

    // =========================
    // Pan / zoom
    // =========================
    function secondsPerPixel(){
      const rect = chartCanvas.getBoundingClientRect();
      const w = Math.max(1, rect.width);
      return state.spanSec / w;
    }
    function beginDrag(clientX){
      state.dragging = true;
      state.dragStartX = clientX;
      state.dragStartCenter = state.centerTe;
    }
    function moveDrag(clientX){
      if (!state.dragging || !state.points.length) return;
      const dx = clientX - state.dragStartX;
      const dSec = dx * secondsPerPixel();
      state.centerTe = state.dragStartCenter - dSec;
      applyWindow(false);
      updateAtCenter(true);
    }
    function endDrag(){ state.dragging = false; }
    function attachPanHandlers(el){
      el.addEventListener("pointerdown", (e) => {
        if (!state.points.length) return;
        el.setPointerCapture(e.pointerId);
        beginDrag(e.clientX);
      });
      el.addEventListener("pointermove", (e) => moveDrag(e.clientX));
      el.addEventListener("pointerup", endDrag);
      el.addEventListener("pointercancel", endDrag);
    }
    attachPanHandlers(chartCanvas);
    attachPanHandlers(videoTimeline);

    zoomInBtn.addEventListener("click", () => {
      if (!state.points.length) return;
      state.spanSec = clamp(state.spanSec * 0.6, 2, Math.max(2, state.duration + state.padStartSec));
      applyWindow(true);
      updateAtCenter(true);
    });
    zoomOutBtn.addEventListener("click", () => {
      if (!state.points.length) return;
      state.spanSec = clamp(state.spanSec / 0.6, 2, Math.max(2, state.duration + state.padStartSec));
      applyWindow(true);
      updateAtCenter(true);
    });
    centerZeroBtn.addEventListener("click", () => {
      if (!state.points.length) return;
      state.centerTe = 0;
      applyWindow(true);
      updateAtCenter(true);
    });

    // =========================
    // Playback
    // =========================
    function setPlaying(on){
      state.playing = on;
      state.playLastTs = performance.now();
      playPauseBtn.textContent = on ? "Pause" : "Play";
      if (state.vLoaded) {
        if (on && centerIsInVideo()) videoEl.play().catch(()=>{});
        if (!on) videoEl.pause();
      }
    }
    function stepCenter(dt){
      if (!state.points.length) return;
      state.centerTe = clamp(state.centerTe + dt, -state.padStartSec, state.duration);
      applyWindow(true);
      updateAtCenter(true);
      if (state.vLoaded && state.playing && centerIsInVideo()) {
        const vt = state.centerTe - getOffsetSec();
        videoEl.currentTime = clamp(vt, 0, videoEl.duration);
        videoEl.play().catch(()=>{});
      }
    }
    playPauseBtn.addEventListener("click", () => {
      if (!state.points.length) return;
      setPlaying(!state.playing);
    });
    back10Btn.addEventListener("click", () => stepCenter(-10));
    fwd10Btn.addEventListener("click", () => stepCenter(+10));

    // =========================
    // File inputs + settings
    // =========================
    function loadVideo(file){
      // IMPORTANT: treat lastModified as video START time (best-effort)
      state.videoStartAbsMs = Number.isFinite(file.lastModified) ? file.lastModified : null;

      const url = URL.createObjectURL(file);
      videoEl.src = url;
      videoEl.load();
    }

    videoEl.addEventListener("loadedmetadata", () => {
      state.vLoaded = Number.isFinite(videoEl.duration) && videoEl.duration > 0;
      state.vDuration = state.vLoaded ? videoEl.duration : NaN;

      // try auto-align immediately if CSV already loaded
      maybeAutoAlign("video");

      drawVideoTimeline();
      updateAtCenter(false);
    });

    videoFileEl.addEventListener("change", (e) => {
      const f = e.target.files?.[0];
      if (f) loadVideo(f);
    });

    csvFileEl.addEventListener("change", async (e) => {
      const f = e.target.files?.[0];
      if (!f) return;
      try { await loadCSV(f); }
      catch (err) { showNotice(err?.message || String(err)); console.error(err); }
    });

    btnFit.addEventListener("click", fitTrackBtn);

    // manual offset edits
    offsetEl.addEventListener("input", () => {
      drawVideoTimeline();
      updateAtCenter(true);
      if (state.vLoaded && state.points.length) updateVideoPlacementNotice();
    });

    btnSetOffset.addEventListener("click", () => {
      if (!state.vLoaded) return;
      const vt = videoEl.currentTime || 0;
      setOffsetSec(state.centerTe - vt);
      drawVideoTimeline();
      updateAtCenter(true);
      if (state.points.length) updateVideoPlacementNotice();
    });

    btnAutoAlign.addEventListener("click", () => {
      maybeAutoAlign("button");
    });

    // timezone shift helpers
    tzMinusBtn.addEventListener("click", () => {
      const v = getTzShiftHours();
      tzShiftEl.value = String(v - 1);
    });
    tzPlusBtn.addEventListener("click", () => {
      const v = getTzShiftHours();
      tzShiftEl.value = String(v + 1);
    });
    tzApplyBtn.addEventListener("click", () => {
      // re-run auto-align using current tzShiftHours
      maybeAutoAlign("tzApply");
    });

    window.addEventListener("resize", () => {
      applyWindow(true);
      drawVideoTimeline();
      try{ map.invalidateSize(); }catch(e){}
    });

    // =========================
    // Main loop
    // =========================
    function loop(){
      const now = performance.now();

      if (state.playing && state.points.length) {
        const dt = (now - state.playLastTs)/1000;
        state.playLastTs = now;

        state.centerTe = clamp(state.centerTe + dt, -state.padStartSec, state.duration);
        applyWindow(false);
        updateAtCenter(false);

        // keep video synced only while center is inside segment (CSV keeps going after video ends)
        if (state.vLoaded && centerIsInVideo()) {
          const vt = state.centerTe - getOffsetSec();
          if (videoEl.ended || Math.abs(videoEl.currentTime - vt) > 0.30) {
            videoEl.currentTime = clamp(vt, 0, videoEl.duration);
          }
          if (videoEl.paused) videoEl.play().catch(()=>{});
        }
      } else {
        // idle readouts
        if (state.vLoaded) {
          vRead.textContent = fmtClock(videoEl.currentTime);
          inVidRead.textContent = centerIsInVideo() ? "IN VIDEO" : "outside video";
        } else {
          vRead.textContent = "—";
          inVidRead.textContent = "no video";
        }
      }

      state.raf = requestAnimationFrame(loop);
    }
    state.playLastTs = performance.now();
    state.raf = requestAnimationFrame(loop);
  </script>
</body>
</html>
